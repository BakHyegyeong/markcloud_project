export interface BlockingQueueOptions {
    /**
     * Number of pending unread items.
     *
     * Must be an integer from 0 and up or `Infinity`, must be >= `concurrency`.
     *
     * @default 8
     */
    readonly maxUnread?: number;
}
/**
 * `enqueue` blocks when the queue is full, until an item is read with `dequeue`, or done
 * `dequeue` blocks when the queue is empty, until an item is added with `enqueue`, or done
 * `done` must be called when no more items will be added
 * `dequeue` returns `undefined` there are no more items and processing is complete
 *
 * @category Low-Level
 */
export declare class BlockingQueue<Element> {
    private _options;
    private readonly _unreadQueue;
    private readonly _readersWaiting;
    private readonly _writersWaiting;
    private _doneAdding;
    /**
     * Create a new `BlockingQueue`
     *
     * @param options BlockingQueue options
     */
    constructor(options?: BlockingQueueOptions);
    get length(): number;
    /**
     * Indicate that no more items will be enqueued.
     *
     * This releases all readers blocked on `enqueue`
     */
    done(): void;
    /**
     * Add an item to the queue, wait if the queue is full.
     *
     * @param item Element to add
     */
    enqueue(item: Element): Promise<void>;
    /**
     * Gets an element when one is ready, waits if none are ready.
     *
     * @returns Element or undefined if queue is empty and `done` has been called
     */
    dequeue(): Promise<Element | undefined>;
    private releaseAllReaders;
    private areWeDone;
    /**
     * Waits for an item to be ready in the queue
     */
    private waitForWrite;
    /**
     * Waits to be able to add an item to the queue when full
     */
    private waitForRead;
}
//# sourceMappingURL=blocking-queue.d.ts.map